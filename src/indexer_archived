    fn write_to_buffer<'a>(doc_id:u32,word_index:u32,law:u8,w:u128,raw:u8,wb:&mut WordBlock2, buffer: &mut bumpalo::collections::vec::Vec<'a,u8>)
    {
        //Write the doc_id if necessary
        if doc_id!=wb.latest_doc_id
        {
            //Write terminator bytes for previous doc
            if buffer.len() > 0
            {
                buffer.push(0x7f); 
                buffer.push(0xff);
            }

            wb.latest_doc_id = doc_id;
            let b1 : u8 = ((doc_id >> 24) & 0xff) as u8;
            let b2 : u8 = ((doc_id >> 16) & 0xff) as u8;
            let b3 : u8 = ((doc_id >> 8) & 0xff) as u8;
            let b4 : u8 = (doc_id & 0xff) as u8;
            buffer.extend([b1, b2, b3, b4].iter().copied());
            
            wb.latest_index = 0; //Don't forget to reset the latest index
        }

        //Calculate the offset
        let offset  = word_index - wb.latest_index;
        let is_offset_overflow = offset >= 32766;

        let mut more_ind = 0; //initial more indicator
    
        //set more indicator to true if there is law or raw or offset overflow
        if law != 255 || raw!=255 || is_offset_overflow
        {
            more_ind = 0b10000000;
        }

        //if there is no offset overflow
        if !is_offset_overflow
        {
            //push first two bytes with offset information and more indicator

            //println!("    b1:{}", format!("{:08b}", b1));
            //println!("    b2:{}", format!("{:08b}", b2));


            buffer.push(((offset as u16 >> 8) as u8 | more_ind) as u8);
            buffer.push((offset as u16 & 0xff) as u8);

            if law !=255 && raw==255 //If left is set
            {
                buffer.push(0b10000000 | law);
            }
            else if raw != 255 && law==255 //If right is set
            {
                buffer.push(0b01000000 | raw);
            }
            else if law!=255 && raw != 255 //if both
            {
                buffer.push(0b11000000 | law);
                buffer.push(raw);
            }

        }
        else //This indicates offset overflow.
        {
            //Write the firt 15 bits of the offset address along with more_ind
            buffer.push(((offset as u16 >> 8) as u8 | more_ind) as u8);
            buffer.push((offset as u16 & 0xff) as u8);

            //0b0001
            let mut ext_byte = (offset as u32 >> 15) as u8 & 0b00011111;

            //if law or raw is present explicitly set the ext_more bit.
            if law !=255 || raw != 255
            {
                ext_byte = ext_byte | 0b00100000;
            }
        
            //push the 5 remaining extended offset address bits  along with 3 leading bits 00 & 0 or 1 depending on the presence of law and/or raw
            buffer.push(ext_byte);

            if law !=255 && raw==255 //If left is set
            {
                buffer.push(0b10000000 | law);
            }
            else if raw != 255 && law==255 //If right is set
            {
                buffer.push(0b01000000 | raw);
            }
            else if law!=255 && raw != 255 //if both
            {
                buffer.push(0b11000000 | law);
                buffer.push(raw);
            }

        }
    }

    //adds a word position to a particular WordBlock along with adjacent words
    fn add_word_to_hash_map_2<'a>(doc_id:u32,word_index:u32,law:u8,w:u128,raw:u8,hm:&mut HashMap<u128,WordBlock2>, bump: &'a bumpalo::Bump,
        main_buffer_cell:&RefCell<bumpalo::collections::Vec<'a,bumpalo::collections::Vec<'a, u8>>>
    )
    {

        let mut main_buffer = main_buffer_cell.borrow_mut();

        //let wb = hm.entry(w).or_insert_with(|| WordBlock {buffer:Vec::with_capacity(8 as usize),latest_doc_id:0,latest_index:0,word_count:0,capacity:0,address:0,position:0});
        
        let wb = hm.entry(w).or_insert_with(|| WordBlock2 {buffer_id:-1,latest_doc_id:0,latest_index:0,word_count:0,capacity:0,address:0,position:0});

        

        //Check if it's time to allocate a new buffer
        if wb.buffer_id == -1
        {
            wb.buffer_id = main_buffer.len() as i32; //assign buffer id
            let mut buffer = bumpalo::collections::Vec::new_in(&bump); //allocate new buffer

            write_to_buffer(doc_id,word_index,law,w,raw,wb,& mut buffer);
            //let ref_cell:RefCell<bumpalo::collections::Vec<u8>> = RefCell::new(buffer);
            main_buffer.push(buffer); 
            
        }
        else
        {
            //let mut content = &mut *content_ref.borrow_mut();
            let buffer = &mut main_buffer[wb.buffer_id as usize];
            write_to_buffer(doc_id,word_index,law,w,raw,wb,buffer);
        }

        wb.latest_index = word_index; //Make sure to set the latest_index
        wb.word_count = wb.word_count + 1;
    }

        fn index_old(doc_files: &Vec<String>, hm: &mut HashMap<u128,WordBlock>, common_word_path:&str,collection_index:u32,collection_count: u32, worker_id:u8, worker_count:u8, limit:u32, realoc_count:&mut u32)
    {
        //let full_path = Path::new(source_path).join(doc_collection.to_string()).display().to_string();

        let mut com:HashMap<u128, u8> =  HashMap::new();
        common_words::load(common_word_path, & mut com).expect("Error Loading common words.");

        //let mut doc_files = Vec::new();
        //get_files_by_hash_bucket(&source_path,collection_index,collection_count, & mut doc_files).expect("Error Loading source file path.");


        let mut docs_to_process = Vec::new();
        get_files_by_hash_bucket(doc_files, collection_index,collection_count,worker_id,worker_count,limit, &mut docs_to_process).unwrap();
        //doc_files.sort();

        let mut count = 0;
        let mut content = String::with_capacity(1000000);
        for doc_file in docs_to_process 
        {
            //println!("worker:{} doc:{}",worker_id,doc_file);
      
            if limit !=0 && count >= limit
            {
                break;
            }

            if doc_file == ""
            {
                break;
            }

            let doc_id = get_doc_id(&doc_file);
            //skip if unable 
            if doc_id == 0  
            {
                println!("Could not get doc id from: {}", doc_file);
                continue;
            }

            //parse_file(doc_id, &doc_file, &mut content, hm, &com).expect("Unable to parse file.");


            {
                let mut file = File::open(doc_file).unwrap();
                file.read_to_string(&mut content).unwrap();
            }

            // Read all the file content into a variable (ignoring the result of the operation).
            let mut word_index:u32 = 0;

            //let mut l:u128;
            let mut w:u128;
            let mut r:u128 = 0;

            let nomatch:u8 = 255;
        
            let mut rawh:u8 = nomatch;
            let mut cw:u8 = nomatch;
            let mut lawh:u8;

            let mut word = String::with_capacity(200);
            
            for c in content.chars() 
            { 
                if c.is_alphanumeric() || c=='\''
                {
                    word.push(c.to_ascii_lowercase());
                }
                else 
                {
                    if word.len() > 0
                    {
                        //l = w;
                        lawh = cw;
                        
                        w = r;
                        cw = rawh;
                        
                        r = word_hash::hash_word_to_u128(&word);
                        rawh = common_words::map_to(&com,&r);

                        
                        //only add if not a common word.
                        if cw==nomatch && w!=0
                        {
                            add_word_to_hash_map(doc_id,word_index - 1, lawh, w, rawh, hm, realoc_count);
                        }
                        
                        word.clear();
                        word_index = word_index + 1;
                    }
                }
            }
            if word.len() > 0
            {
                
                //l = w;
                lawh = cw;
                
                w = r;
                cw = rawh;
                
                r = word_hash::hash_word_to_u128(&word);
                rawh = common_words::map_to(&com,&r);

                //only add if not a common word.
                if cw==255 && w!=0
                {
                    add_word_to_hash_map(doc_id,word_index - 1, lawh, w, rawh, hm, realoc_count);
                }

                //finally if at the end also add the last word if not common.println!
                //only add if not a common word.
                if rawh==255 && r!=0
                {
                    add_word_to_hash_map(doc_id,word_index, cw, r, nomatch, hm, realoc_count);
                }
                word_index = word_index + 1;
            }

            content.truncate(0);
        
               
        }

        add_terminators(hm);

        println!("worker_id: {:?}  count: {:?}", worker_id, count);
    }


       /*
    fn get_files_by_hash_bucket(directory: &str,collection_index:u32,collection_count: u32, v:&mut Vec<String>) -> io::Result<()> {
        let dirs =  fs::read_dir(directory).unwrap();
        for dir in dirs
        {
            let entry = dir.unwrap().path();
            if entry.is_dir()
            {
                let sub_dir = entry.display().to_string();
                let files_dir =  fs::read_dir(sub_dir).unwrap();

                for file in files_dir
                {
                    let file_entry = file.unwrap().path();
                    if !file_entry.is_dir()
                    {
                        let file = file_entry.display().to_string();
                        let hash_bucket = get_hash_bucket(&file, collection_count);
                        //only add file if hash_bucket matches
                        if hash_bucket == collection_index 
                        {
                            v.push(file);
                        }
                        
                    }
           
                }

                
            }
        }

        Ok(())
    }
    */

    /*
    fn index(hm: &mut HashMap<u128,WordBlock>, source_path:&str, common_word_path:&str,collection_index:u32,collection_count: u32, worker_id:u8, worker_count:u8, limit:u32)
    {
        //let full_path = Path::new(source_path).join(doc_collection.to_string()).display().to_string();

        let mut com:HashMap<u128, u8> =  HashMap::new();
        common_words::load(common_word_path, & mut com).expect("Error Loading common words.");

        let mut doc_files = Vec::new();
        get_files_by_hash_bucket(&source_path,collection_index,collection_count, & mut doc_files).expect("Error Loading source file path.");

        doc_files.sort();

        let mut count = 0;
    
        for doc_file in doc_files 
        {
            if limit !=0 && count >= limit
            {
                break;
            }

            if doc_file == ""
            {
                break;
            }

            let doc_id = get_doc_id(&doc_file);
            //skip if unable 
            if doc_id == 0  
            {
                println!("Could not get doc id from: {}", doc_file);
                continue;
            }

            if (doc_id % worker_count as u32) as u8 == worker_id || worker_id == 255
            {
                parse_file2(doc_id, &doc_file, hm, &com).expect("Unable to parse file.");
                count = count + 1;
            }
            //println!("{}", &doc_file);
        }

        add_terminators(hm);

        println!("worker_id: {:?}  count: {:?}", worker_id, count);
    }
    */


    fn index2<'b>(doc_files: &Vec<String>, hm: &mut HashMap<u128,WordBlock2>, common_word_path:&str,collection_index:u32,collection_count: u32, 
        worker_id:u8, worker_count:u8, limit:u32, 
        arena: &'b bumpalo::Bump,
        //main_buffer:&'b mut bumpalo::collections::Vec<'b,bumpalo::collections::Vec<'b, u8>>
        main_buffer_cell:&RefCell<bumpalo::collections::Vec<'b,bumpalo::collections::Vec<'b, u8>>>
    )
    {
        //let full_path = Path::new(source_path).join(doc_collection.to_string()).display().to_string();

        let mut com:HashMap<u128, u8> =  HashMap::new();
        common_words::load(common_word_path, & mut com).expect("Error Loading common words.");

        //let mut doc_files = Vec::new();
        //get_files_by_hash_bucket(&source_path,collection_index,collection_count, & mut doc_files).expect("Error Loading source file path.");


        let mut docs_to_process = Vec::new();
        get_files_by_hash_bucket(doc_files, collection_index,collection_count,worker_id,worker_count,limit, &mut docs_to_process).unwrap();
        //doc_files.sort();

        let mut count = 0;
        let content_ref:RefCell<Vec<u8>> = RefCell::new(Vec::with_capacity(1000000));
    
        for doc_file in docs_to_process 
        {
            //println!("worker:{} doc:{}",worker_id,doc_file);
      
            if limit !=0 && count >= limit
            {
                break;
            }

            if doc_file == ""
            {
                break;
            }

            let doc_id = get_doc_id(&doc_file);
            //skip if unable 
            if doc_id == 0  
            {
                println!("Could not get doc id from: {}", doc_file);
                continue;
            }

            //parse_file(doc_id, &doc_file, &mut content, hm, &com).expect("Unable to parse file.");

          
            let mut file = File::open(doc_file).unwrap();
            let mut content = &mut *content_ref.borrow_mut();
            content.clear();
            file.read_to_end(&mut content).unwrap();

            // Read all the file content into a variable (ignoring the result of the operation).
            let mut word_index:u32 = 0;

            //let mut l:u128;
            let mut w:u128;
            let mut r:u128 = 0;

            let nomatch:u8 = 255;
        
            let mut rawh:u8 = nomatch;
            let mut cw:u8 = nomatch;
            let mut lawh:u8;
       
            let mut word: Vec<u8> = Vec::with_capacity(20);
           
                        
            for c in content
            { 
                if (*c as char).is_alphanumeric() || (*c as char)=='\''
                {
                    word.push(*c);
                }
                else 
                {
                    if word.len() > 0
                    {
                        //l = w;
                        lawh = cw;
                        
                        w = r;
                        cw = rawh;
                        
                        r = word_hash::hash_v_word_to_u128(&word);
                        rawh = common_words::map_to(&com,&r);

                        
                        //only add if not a common word.
                        if cw==nomatch && w!=0
                        {
                            add_word_to_hash_map_2(doc_id,word_index - 1, lawh, w, rawh, hm, arena, &main_buffer_cell);
                        }
                        
                        word.clear();
                        word_index = word_index + 1;
                    }
                }

                
            }
            if word.len() > 0
            {
                
                //l = w;
                lawh = cw;
                
                w = r;
                cw = rawh;
                
                r = word_hash::hash_v_word_to_u128(&word);
                rawh = common_words::map_to(&com,&r);

                //only add if not a common word.
                if cw==255 && w!=0
                {
                    //add_word_to_hash_map_2(doc_id,word_index - 1, lawh, w, rawh, hm, arena, &mut *main_buffer);
                }

                //finally if at the end also add the last word if not common.println!
                //only add if not a common word.
                if rawh==255 && r!=0
                {
                    //add_word_to_hash_map_2(doc_id,word_index - 1, cw, r, nomatch, hm, arena, &mut *main_buffer);
               
                }
                word_index = word_index + 1;
            }

            count+=1;
        }

        //TODO:Fix this
        //add_terminators(hm);

        println!("worker_id: {:?}  count: {:?}", worker_id, count);
    }